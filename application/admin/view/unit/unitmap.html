<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <style type="text/css">
        body, html{width: 100%;height: 100%;margin:0;font-family:"微软雅黑";}
        #allmap{height:100%;width:100%;}
    </style>
    <script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&ak=DD279b2a90afdf0ae7a3796787a0742e"></script>
    <title>城市名定位</title>
</head>
<body>
<div id="r-result" style="position:absolute; z-index:2;" >
    <label>区域/城市名: </label><input id="cityName" type="text" style="width:200px; margin-right:10px;" />
    <input type="button" value="查询" onclick="theLocation()" />
</div>
<div id="allmap"></div>
<!--start初始化数据-->
<input type="hidden" id="x_point" value="{$x_point}">
<input type="hidden" id="y_point" value="{$y_point}">
{foreach $map_zones as $key=>$value }
<input type="hidden" name="map_zone" data_name="{$key}" data_points="{$value}">
{/foreach}
<!--end 初始化数据-->
</body>
</html>
<script type="text/javascript">
    // 百度地图API功能
    var map = new BMap.Map("allmap");
    //var point = new BMap.Point(108.296402,22.844226);
    var point = new BMap.Point(110.834891,24.837219);
    map.centerAndZoom(point,18);
    map.enableScrollWheelZoom(true);//鼠标滚轮可缩放地图
    var opts = {offset: new BMap.Size(0, 0)} //定义偏移坐标
    map.addControl(new BMap.NavigationControl({offset: new BMap.Size(0, 30)}));//导航坐标
    map.addControl(new BMap.OverviewMapControl(opts));//缩略图
    map.addControl(new BMap.MapTypeControl(opts));//地图类型
    map.addControl(new BMap.ScaleControl({offset: new BMap.Size(0, 50)}));//添加控件（比例尺），并将空件偏移

    //start 如果是修改操作，则初始化地图标注
    var x_point = document.getElementById('x_point').value;
    var y_point = document.getElementById('y_point').value;
    if((x_point != '') && (y_point != '')){
        //alert(x_point + ", " + y_point);
        //map.clearOverlays();//清除图层
        var point = new BMap.Point(x_point, y_point);
        map.centerAndZoom(point,18);
        var marker = new BMap.Marker(point);  // 创建标注
        map.addOverlay(marker);               // 将标注添加到地图中
        marker.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画
    }
    //end 如果是修改操作，则初始化地图标注

    // 创建地址解析器实例
    var myGeo = new BMap.Geocoder();
    //start 地点查询
    function theLocation(){
        var city = document.getElementById("cityName").value;
        if(city != ""){
            map.centerAndZoom(city,18);      // 用城市名设置地图中心点

            // 将地址解析结果显示在地图上,并调整地图视野
            myGeo.getPoint(city, function(point){
                if (point) {
                    map.clearOverlays();//清除图层
                    map.centerAndZoom(point, 18);
                    var marker = new BMap.Marker(point);  // 创建标注
                    map.addOverlay(marker);               // 将标注添加到地图中
                    marker.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画
                }else{
                    alert("抱歉，您输入的地址没有查到!");
                }
            }, city);
        }
    }
    //end 地点查询

    //start 鼠标定点标注
    function showInfo(e){
        map.clearOverlays();//清除图层
        //alert(e.point.lng + ", " + e.point.lat);
        var point = new BMap.Point(e.point.lng, e.point.lat);
        var marker = new BMap.Marker(point);  // 创建标注
        map.addOverlay(marker);               // 将标注添加到地图中
        parent.document.getElementById('x_point').value = e.point.lng ;
        parent.document.getElementById('y_point').value = e.point.lat;
        var zone_name = checkBelongZone(point);
//        var select = parent.document.getElementById('zone_id');
//        for(var i=0; i<select.options.length; i++){
//            console.log(select.options[i].innerHTML);
//            if(select.options[i].innerHTML == zone_name){
//                select.options[i].selected = true;
//                break;
//            }
//        }
        var select = parent.document.getElementById('zone_id');
        for(var i=0; i<select.options.length; i++){
            if(select.options[i].innerHTML == zone_name){
                select.options[i].selected = true;
                break;
            }
        }

    }
    map.addEventListener("click", showInfo);
    //end 鼠标定点标注


    //start 计算单位坐标点所属区域
    function checkBelongZone(point) {
        var map_zone = document.getElementsByName('map_zone');
        for (var i = 0; i < map_zone.length; i++) {
            var zone_name = map_zone[i].attributes["data_name"].nodeValue;
            var zone_points = map_zone[i].attributes["data_points"].nodeValue;
            var polygon = createBoundaryMy(zone_points);//生成边界
            if(isPointInPolygon(point, polygon)){
                return zone_name;
            }
        }
    }
    //end 计算单位坐标点所属区域

    //start 自定义区域显示
    function  createBoundaryMy(zone_points) {
        var points=eval("("+zone_points+")");
        var polygon = new BMap.Polygon(points, {strokeColor:"#888877", strokeWeight:3, strokeOpacity:1});  //创建多边形
        return polygon;
    }
    //end 自定义区域显示

    //start 多边形区域搜索
    function isPointInPolygon(point, polygon){
        //检查类型
        if(!(point instanceof BMap.Point) ||
                !(polygon instanceof BMap.Polygon)){
            return false;
        }

        //首先判断点是否在多边形的外包矩形内，如果在，则进一步判断，否则返回false
        var polygonBounds = polygon.getBounds();
        if(!isPointInRect(point, polygonBounds)){
            return false;
        }

        var pts = polygon.getPath();//获取多边形点

        //基本思想是利用射线法，计算射线与多边形各边的交点，如果是偶数，则点在多边形外，否则
        //在多边形内。还会考虑一些特殊情况，如点在多边形顶点上，点在多边形边上等特殊情况。
        var N = pts.length;
        var boundOrVertex = true; //如果点位于多边形的顶点或边上，也算做点在多边形内，直接返回true
        var intersectCount = 0;//cross points count of x
        var precision = 2e-10; //浮点类型计算时候与0比较时候的容差
        var p1, p2;//neighbour bound vertices
        var p = point; //测试点

        p1 = pts[0];
        for(var i = 1; i <= N; ++i){
            if(p.equals(p1)){
                return boundOrVertex;
            }

            p2 = pts[i % N];
            if(p.lat < Math.min(p1.lat, p2.lat) || p.lat > Math.max(p1.lat, p2.lat)){
                p1 = p2;
                continue;
            }

            if(p.lat > Math.min(p1.lat, p2.lat) && p.lat < Math.max(p1.lat, p2.lat)){
                if(p.lng <= Math.max(p1.lng, p2.lng)){
                    if(p1.lat == p2.lat && p.lng >= Math.min(p1.lng, p2.lng)){
                        return boundOrVertex;
                    }

                    if(p1.lng == p2.lng){
                        if(p1.lng == p.lng){
                            return boundOrVertex;
                        }else{
                            ++intersectCount;
                        }
                    }else{
                        var xinters = (p.lat - p1.lat) * (p2.lng - p1.lng) / (p2.lat - p1.lat) + p1.lng;
                        if(Math.abs(p.lng - xinters) < precision){
                            return boundOrVertex;
                        }

                        if(p.lng < xinters){
                            ++intersectCount;
                        }
                    }
                }
            }else{
                if(p.lat == p2.lat && p.lng <= p2.lng){
                    var p3 = pts[(i+1) % N];
                    if(p.lat >= Math.min(p1.lat, p3.lat) && p.lat <= Math.max(p1.lat, p3.lat)){
                        ++intersectCount;
                    }else{
                        intersectCount += 2;
                    }
                }
            }
            p1 = p2;
        }

        if(intersectCount % 2 == 0){
            return false;
        } else {
            return true;
        }
    }
    //end 多边形区域搜索

    //start 判断点是否在矩形内
    function isPointInRect(point, bounds){
        //检查类型是否正确
        if (!(point instanceof BMap.Point) ||
                !(bounds instanceof BMap.Bounds)) {
            return false;
        }
        var sw = bounds.getSouthWest(); //西南脚点
        var ne = bounds.getNorthEast(); //东北脚点
        return (point.lng >= sw.lng && point.lng <= ne.lng && point.lat >= sw.lat && point.lat <= ne.lat);
    }
    //end 判断点是否在矩形内

</script>